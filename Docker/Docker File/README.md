# üê≥ **Dockerfile Components**

A Dockerfile defines what will be included in your Docker image. Below are the most commonly used instructions in a Dockerfile, along with their functions and examples.

---

## 1. **FROM**
- **Description**: This instruction sets the base image for the Docker image. Every Dockerfile must start with a `FROM` instruction. It defines the parent image from which the build starts.
- **Example**:
    ```dockerfile
    FROM ubuntu:20.04
    ```
    **Explanation**: This sets the base image as Ubuntu 20.04. Any following instructions will add onto this image.

---

## 2. **LABEL**
- **Description**: Adds metadata to an image in the form of key-value pairs. Labels can describe the image's author, version, or other details.
- **Example**:
    ```dockerfile
    LABEL maintainer="youremail@example.com"
    LABEL version="1.0"
    LABEL description="This is a sample image for a web app."
    ```
    **Explanation**: Adds labels to the image that specify who maintains it, the version, and a brief description.

---

## 3. **RUN**
- **Description**: Executes commands during the build process to install dependencies or configure the environment. Each `RUN` command creates a new layer in the image.
- **Example**:
    ```dockerfile
    RUN apt-get update && apt-get install -y python3 python3-pip
    ```
    **Explanation**: This updates the package list and installs Python and pip in the container.

---

## 4. **CMD**
- **Description**: Specifies the default command to run when a container starts. Only one `CMD` instruction can be used in a Dockerfile. If multiple `CMD` instructions are specified, only the last one will be executed.
- **Example**:
    ```dockerfile
    CMD ["python3", "app.py"]
    ```
    **Explanation**: When the container starts, it will execute `python3 app.py`. This should be used to specify the main command that runs the application.

---

## 5. **ENTRYPOINT**
- **Description**: Similar to `CMD`, but it allows you to configure the container to run as an executable. The `ENTRYPOINT` command is the command that will always run, while `CMD` provides default arguments to that command.
- **Example**:
    ```dockerfile
    ENTRYPOINT ["python3", "app.py"]
    ```
    **Explanation**: The container will always execute `python3 app.py` when it starts.

- **Example with CMD and ENTRYPOINT**:
    ```dockerfile
    ENTRYPOINT ["python3"]
    CMD ["app.py"]
    ```
    **Explanation**: This runs `python3 app.py` by default but allows users to override the command by providing a different argument (e.g., `docker run <image> other_script.py`).

---

## 6. **COPY**
- **Description**: Copies files or directories from the host machine to the image. It‚Äôs typically used to copy application code or other files into the container.
- **Example**:
    ```dockerfile
    COPY . /app
    ```
    **Explanation**: This copies the contents of the current directory (on the host) into the `/app` directory inside the container.

---

## 7. **ADD**
- **Description**: Similar to `COPY`, but with more functionality. `ADD` can also copy files from remote URLs and automatically unpack compressed files like `.tar` or `.gz` archives.
- **Example**:
    ```dockerfile
    ADD my_archive.tar.gz /app
    ```
    **Explanation**: This adds and unpacks the `my_archive.tar.gz` file into the `/app` directory in the container.

---

## 8. **WORKDIR**
- **Description**: Sets the working directory for any `RUN`, `CMD`, `ENTRYPOINT`, `COPY`, and `ADD` instructions that follow. If the directory doesn‚Äôt exist, it will be created.
- **Example**:
    ```dockerfile
    WORKDIR /app
    ```
    **Explanation**: Sets `/app` as the working directory for the following commands, meaning any command will run from that directory.

---

## 9. **EXPOSE**
- **Description**: Informs Docker that the container will listen on the specified network ports at runtime. It doesn‚Äôt actually publish the ports; you need to use `-p` when running the container to publish the port.
- **Example**:
    ```dockerfile
    EXPOSE 8080
    ```
    **Explanation**: This informs Docker that the container will expose port 8080 for incoming network traffic.

---

## 10. **ENV**
- **Description**: Sets environment variables within the container. These variables will persist inside the container for any following instructions and running applications.
- **Example**:
    ```dockerfile
    ENV NODE_ENV=production
    ```
    **Explanation**: This sets the environment variable `NODE_ENV` to `production`. It can be accessed by processes running in the container.

---

## 11. **VOLUME**
- **Description**: Creates a mount point with a specified path and marks it as a volume. Volumes are used to persist data generated by the container.
- **Example**:
    ```dockerfile
    VOLUME /data
    ```
    **Explanation**: Creates a volume at `/data`, allowing data stored in this directory to persist between container restarts.

---

## 12. **USER**
- **Description**: Sets the user name (or UID) and optionally the group (or GID) to use when running the container. It‚Äôs commonly used to ensure the container doesn‚Äôt run as `root`, improving security.
- **Example**:
    ```dockerfile
    USER appuser
    ```
    **Explanation**: This changes the user to `appuser`, so all commands from this point on will run as that user instead of `root`.

---

## 13. **HEALTHCHECK**
- **Description**: Defines a command to test whether the container is still running as expected. You can specify retries, intervals, and timeouts.
- **Example**:
    ```dockerfile
    HEALTHCHECK --interval=30s --timeout=3s --retries=3 CMD curl --fail http://localhost:8080 || exit 1
    ```
    **Explanation**: This checks every 30 seconds if the application is reachable at `http://localhost:8080`. If the health check fails 3 times, the container will be marked as unhealthy.

---

## 14. **ARG**
- **Description**: Defines a build-time variable that can be passed as an argument to the Docker build process. Unlike `ENV`, `ARG` is only available during the image build, not when running the container.
- **Example**:
    ```dockerfile
    ARG VERSION=1.0
    RUN echo "Building version $VERSION"
    ```
    **Explanation**: This sets a build-time variable `VERSION` with a default value of `1.0`. You can override this value by passing `--build-arg VERSION=2.0` during the `docker build` command.

---

## 15. **ONBUILD**
- **Description**: Adds a trigger instruction to the image. When the resulting image is used as a base for another build, the `ONBUILD` instruction will run automatically.
- **Example**:
    ```dockerfile
    ONBUILD ADD . /app
    ```
    **Explanation**: This will automatically copy the current directory to `/app` if this image is used as the base for another Dockerfile.

---

## 16. **SHELL**
- **Description**: Allows you to define the shell used to run commands in the Dockerfile. By default, Docker uses `sh -c` on Linux and `cmd /S /C` on Windows.
- **Example**:
    ```dockerfile
    SHELL ["powershell", "-Command"]
    ```
    **Explanation**: This changes the default shell to PowerShell for subsequent commands, which is especially useful for Windows-based images.

---

## 17. **STOPSIGNAL**
- **Description**: Sets the system call signal that will be sent to the container to stop it.
- **Example**:
    ```dockerfile
    STOPSIGNAL SIGKILL
    ```
    **Explanation**: Specifies that Docker should send the `SIGKILL` signal to stop the container, ensuring it terminates immediately.

---

## 18. **MAINTAINER** (Deprecated)
- **Description**: This instruction was used to specify the author or maintainer of the image. It has been replaced by the `LABEL` instruction.
- **Example**:
    ```dockerfile
    MAINTAINER John Doe <john.doe@example.com>
    ```

---

## üê≥ **Dockerfile Examples for Node.js, Java, and Golang Applications**

This guide provides Dockerfile examples for creating efficient Docker images for **Node.js**, **Java (Spring Boot)**, and **Golang** applications. Each example is optimized for building production-ready containers with best practices.

---

## 1. **Nodejs Application Dockerfile**

```dockerfile
# Use an official Node.js runtime as a base image
FROM node:16-alpine

# Set the working directory inside the container
WORKDIR /usr/src/app

# Copy the package.json and package-lock.json files
COPY package*.json ./

# Install dependencies (npm ci ensures a clean install of dependencies)
RUN npm ci --only=production

# Copy the rest of the application files to the working directory
COPY . .

# Expose the port the app runs on
EXPOSE 3000

# Define environment variable
ENV NODE_ENV=production

# The command to start the Node.js app
CMD ["npm", "start"]
```

## 2. **Java Application Dockerfile** 
```dockerfile
# Use an official OpenJDK runtime as a parent image
FROM openjdk:11-jre-slim

# Set the working directory inside the container
WORKDIR /app

# Copy the JAR file to the container
COPY target/myapp-0.0.1-SNAPSHOT.jar app.jar

# Expose the port on which the Spring Boot app listens
EXPOSE 8080

# Define environment variable
ENV JAVA_OPTS="-Xmx512m"

# The command to run the Spring Boot app
ENTRYPOINT ["java", "-jar", "app.jar"]

```

## 3. **Golang Application Dockerfile** 
```dockerfile
# Stage 1: Build the Go application
FROM golang:1.19-alpine AS builder

# Set the working directory inside the container
WORKDIR /app

# Copy the go.mod and go.sum files first (for dependency caching)
COPY go.mod go.sum ./

# Download dependencies
RUN go mod download

# Copy the entire application to the container
COPY . .

# Build the Go app (the output binary is called "myapp")
RUN go build -o myapp

# Stage 2: Create a lightweight image for running the application
FROM alpine:latest

# Set the working directory
WORKDIR /app

# Copy the binary from the builder stage
COPY --from=builder /app/myapp .

# Expose the port the app runs on
EXPOSE 8080

# Command to run the Go app
CMD ["./myapp"]
```

---

üìù **Created by ducanhduocdochu**
